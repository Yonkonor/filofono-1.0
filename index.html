<!DOCTYPE html>
<html lang="es">
<head>
    <!-- Mantener mismo head y estilos -->
</head>
<body>
    <!-- Misma estructura HTML -->

    <script>
        let audioContext;
        let oscillators = [];
        let gainNode;
        let isPlaying = false;
        let acceleration = { x: 0, y: 0, z: 0 };
        let lastSensorTimestamp = 0;
        const SENSOR_INTERVAL = 20; // 20ms (50Hz)

        // Configuración de audio optimizada
        const audioSettings = {
            attackTime: 0.01,   // 10ms para ataque rápido
            releaseTime: 0.02, // 20ms para release
            maxGain: 0.5,
            baseFreq: 200,
            vibratoSpeed: 30    // Hz más rápido
        };

        // ... Configuración inicial del gráfico ...

        function calculateGValue() {
            return Math.hypot(acceleration.x, acceleration.y, acceleration.z) / 9.81;
        }

        function createViolinSound() {
            // Configuración de audio optimizada para baja latencia
            audioContext = new (window.AudioContext || window.webkitAudioContext)({
                latencyHint: 'playback' // Priorizar baja latencia
            });

            gainNode = audioContext.createGain();
            gainNode.gain.value = 0;
            gainNode.connect(audioContext.destination);

            // Crear osciladores directamente conectados al gain
            oscillators = [200, 400, 600, 800].map(freq => {
                const osc = audioContext.createOscillator();
                osc.type = 'square'; // Usar forma de onda más responsiva
                osc.frequency.value = freq;
                osc.connect(gainNode);
                osc.start();
                return osc;
            });
        }

        function processSensorData(event) {
            const now = performance.now();
            
            // Filtrar actualizaciones muy frecuentes
            if (now - lastSensorTimestamp < SENSOR_INTERVAL) return;
            lastSensorTimestamp = now;

            acceleration = event.acceleration;
            const currentG = calculateGValue();
            
            // Actualizar interfaz sin bloquear el audio
            requestAnimationFrame(() => {
                gValueDisplay.textContent = currentG.toFixed(2) + ' g';
            });

            // Procesamiento de audio sincronizado con el sensor
            const audioNow = audioContext.currentTime;
            const intensity = Math.min(currentG * 1.2, 2);

            if (currentG < 0.1) {
                gainNode.gain.setTargetAtTime(0, audioNow, audioSettings.releaseTime);
            } else {
                // Actualización directa sin suavizado excesivo
                gainNode.gain.setValueAtTime(
                    intensity * audioSettings.maxGain, 
                    audioNow
                );
                
                // Vibrato de alta velocidad
                oscillators.forEach((osc, i) => {
                    osc.frequency.setValueAtTime(
                        [200, 400, 600, 800][i] + 
                        Math.sin(audioNow * audioSettings.vibratoSpeed) * intensity * 10,
                        audioNow
                    );
                });
            }
        }

        async function toggleSound() {
            if (!isPlaying) {
                try {
                    // Solicitar permiso y alta frecuencia de muestreo
                    if (typeof DeviceMotionEvent.requestPermission === 'function') {
                        await DeviceMotionEvent.requestPermission();
                    }
                    
                    window.addEventListener('devicemotion', processSensorData);
                    createViolinSound();
                    
                    toggleButton.textContent = '⏹';
                    toggleButton.style.backgroundColor = '#f44336';
                    isPlaying = true;
                } catch (error) {
                    alert('Error: ' + error.message);
                }
            } else {
                window.removeEventListener('devicemotion', processSensorData);
                oscillators.forEach(osc => osc.stop());
                audioContext.close();
                toggleButton.textContent = '▶';
                toggleButton.style.backgroundColor = '#2196F3';
                isPlaying = false;
            }
        }

        // ... Resto del código (gráfico y eventos) ...
    </script>
</body>
</html>
